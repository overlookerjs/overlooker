# overlooker

[![Build Status](https://travis-ci.com/overlookerjs/overlooker.svg?branch=master)](https://travis-ci.com/overlookerjs/overlooker) [![npm overlooker package](https://img.shields.io/npm/v/overlooker)](https://www.npmjs.com/package/overlooker)


This package is a set of utilities that allow you to configure your frontend profiling in CI/CD.
At the same time, you will receive comprehensive information about what is contains on your pages.

* [Installation](#installation)
* [Usage](#usage)
  * [Configuration](#configuration-types)
  * [Profiling](#profiling-types)
  * [Impact Analysis](#impact-analysis-types)
  * [Comparison](#comparison-types)
  * [Comparison checking](#comparison-checking-types)
* [Tool for getting build data](#tool-for-getting-build-data)
  
## Installation
```
npm i overlooker
```
## Usage
To set up profiling in CI/CD, you need to write a little code.
This code should link your favorite database and profiling process with several steps.
You can raise a separate server for profiling or organize an API for sending requests
for profiling.

### Configuration [(types)](https://github.com/overlookerjs/overlooker/blob/master/src/types.d.ts#L321)
First, let's figure out how to start profiling.
```js
const config = {
  host: 'https://example.com', // profiling host - it will be concatenated for urls of all pages
  throttling: { // like a throttling in Chrome DevTools Performance
    cpu: 1,
    network: 'WiFi'
  },
  cookies: [{ // an array of cookies to be added for all pages when profiling
      name: 'cookie_name',
      value: 'cookie_value',
      domain: 'example.com'
    }],
  cache: { // used cache - you can use the built-in wpr binary or use your own proxy
    type: 'wpr'
    // for use your own proxy:
    // {
    //   type: 'proxy',
    //   host: string,
    //   restart?: () => Promise<any>
    // }
  },
  count: 10, // number of profiles for each page
  platform: 'desktop', // platform which will be used for profiling (desktop|mobile)
  pages: [{ // array of profiling pages
    name: 'main',
    url: '/',
    layers: {
      meaningfulLayer: '.selector'
    },
    actions: [{ // each page can include several scripts that will be executed after the page is loaded
      name: 'test-action',
      action: async (page) => {
        await page.click('button');
        await page.waitForSelector('#loaded-image');
      }
    }]
  }, {
    name: 'category',
    url: '/'
  }],
  logger: (msg) => console.log(msg), // logger for profiling - it will receive messages during the profiling process
  buildData: { // URL or getter to get build data (generated by Bundle Internals Plugin) to assembly complete profiling data
    url: '/build.json',
  },
  requests: { // some functions for filtering requests
    ignore: (url) => url.includes('ad'), // ignoring some urls by patter
    merge: (url) => url.includes('stats'), // merge duplicate requests
    internalTest: (url) => url.startsWith('https://expample.com') || url.startsWith('https://expample.io'), // pattern for detecting internal resources
  }
};
```

Most of the parameters are optional and the brief config can be as follows:
```js
const config = {
  host: 'https://example.com',
  pages: [{
    name: 'main',
    url: '/',
  }],
  count: 10
};
```

To collect some product metrics, you can use standard API on your pages 
[Element Timing API](https://wicg.github.io/element-timing/)
```html
<span elementtiming="some-element-paint"></span>
```
or [User Timing API](https://developer.mozilla.org/en-US/docs/Web/API/User_Timing_API) 
```js
// first configure patter of mark name in profiling configuration for timings detecting
const config = {
  // ...
  customMetrics: {
    timing: /^product-timing\.(.*?)$/i // use string 'all' for collect all timings
  }
}
```
and on your page you have to execute this:
```js
performance.mark('some-metric');
```


These metrics will be collected during profiling and presented in the resulting json.

### Profiling [(types)](https://github.com/overlookerjs/overlooker/blob/master/src/types.d.ts#L2)
Profiling can be organized in a simple way.
```js
  const { profile } = require('overlooker');

  const profileResult = await profile({
    ...config,
    host: 'https://staging.example.com'
  });

  await db.saveProfile(revision, profileResult);
```
As a result, you will receive data about the performance of your pages in json format.
I recommend saving the data to your favorite database or directly to the file system (do not forget about rotation) with the identifier of the measured revision.

### Impact Analysis [(types)](https://github.com/overlookerjs/overlooker/blob/master/src/types.d.ts#L415)
To reduce the cost of profiling and speed it up, I recommend using the impact analyzer on the page.
To use it, you need the [previous impact analysis data](https://github.com/overlookerjs/overlooker/blob/master/src/types.d.ts#L406).
```js
const { impactAnalysis, affectConfigByImpact } = require('overlooker');

const impactData = await impactAnalysis(
  stagingDescription, // impact data about pages on previous impact analysis
  config, // same configuration as for profiling 
  (element) => element.request.url.includes('ad') // element filtration for collecting stable impact data (for example, you can filter dynamic ad urls) 
);

await db.saveImpactData(revision, impactData);

const impactedConfig = affectConfigByImpact(config, impactData);

```
As a result of executing this code, you will get a configuration with pages that have changes compared to another revision.
Impact analysis data is best saved in a database too.


### Comparison [(types)](https://github.com/overlookerjs/overlooker/blob/master/src/types.d.ts#L224)
After profiling is over, you can use it to compare against a profile with an earlier revision.
or the revision profile from where your branch you are testing was forked from.
```js
const { comparePages } = require('overlooker');

const profileDataFeature = await db.getProfileByRevision(featureRevision);
const profileDataStaging = await db.getProfileByRevision(stagingRevision);

const comparison = comparePages(profileDataStaging, profileDataFeature);
```
As a result of the comparison, you will get the full difference for all metrics,
requests, modules in chunks (if you used bundle-internals-plugin) and this data can already be used for analysis
how much the performance has changed from some edits.

### Comparison checking [(types)](https://github.com/overlookerjs/overlooker/blob/master/src/types.d.ts#L283)
There is also a separate method to check the comparison results. But in the beginning it is worth considering the formation of threshholds.
For them are used special patterns. That will allow you to set up the deviation limits that you need.
Example of thresholds:
```js
const thresholds = {
  default: { // default thresholds (will be used for all pages)
    'percent.stats.userCentric.timeToInteractive.median': 0.05, // path for value in comparison object and limit for deviation
    'percent.stats.elementsTimings.**.median': 0.05
  },
  main: { // threshold for one page, which name is 'main' in profile configuration
    'percent.stats.custom.timings.some-timing.median': 0.1
  }
}
```

And you can use these trashholds to check your comparison
```js
const { check } = require('overlooker');

const result = check(comparison, thresholds);

if (!result.success) {
    return 1; // for example, you can handle the check result and fail the build
}
```

You can also use this approach to budget performance by using the check method
on some profile.
```js
const { check } = require('overlooker');

const result = check(profileDataFeature, budget);
```

## Tool for getting build data
[Bundle Internals Plugin](https://github.com/smelukov/bundle-internals)
